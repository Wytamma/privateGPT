{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"privateGPT","text":"<p>Ask questions to your documents without an internet connection, using the power of LLMs. 100% private, no data leaves your execution environment at any point. You can ingest documents and ask questions without an internet connection!</p> <p>Built with LangChain, GPT4All, LlamaCpp, Chroma and SentenceTransformers.</p> <p></p>"},{"location":"#environment-setup","title":"Environment Setup","text":"<p>In order to set your environment up to run the code here, first install all requirements:</p> <pre><code>pip3 install -r requirements.txt\n</code></pre> <p>Then, download the LLM model and place it in a directory of your choice: - LLM: default to ggml-gpt4all-j-v1.3-groovy.bin. If you prefer a different GPT4All-J compatible model, just download it and reference it in your <code>.env</code> file.</p> <p>Rename <code>example.env</code> to <code>.env</code> and edit the variables appropriately.</p> <pre><code>MODEL_TYPE: supports LlamaCpp or GPT4All\nPERSIST_DIRECTORY: is the folder you want your vectorstore in\nMODEL_PATH: Path to your GPT4All or LlamaCpp supported LLM\nMODEL_N_CTX: Maximum token limit for the LLM model\nEMBEDDINGS_MODEL_NAME: SentenceTransformers embeddings model name (see https://www.sbert.net/docs/pretrained_models.html)\nTARGET_SOURCE_CHUNKS: The amount of chunks (sources) that will be used to answer a question\n</code></pre> <p>Note: because of the way <code>langchain</code> loads the <code>SentenceTransformers</code> embeddings, the first time you run the script it will require internet connection to download the embeddings model itself.</p>"},{"location":"#test-dataset","title":"Test dataset","text":"<p>This repo uses a state of the union transcript as an example.</p>"},{"location":"#instructions-for-ingesting-your-own-dataset","title":"Instructions for ingesting your own dataset","text":"<p>Put any and all your files into the <code>source_documents</code> directory</p> <p>The supported extensions are:</p> <ul> <li><code>.csv</code>: CSV,</li> <li><code>.docx</code>: Word Document,</li> <li><code>.doc</code>: Word Document,</li> <li><code>.enex</code>: EverNote,</li> <li><code>.eml</code>: Email,</li> <li><code>.epub</code>: EPub,</li> <li><code>.html</code>: HTML File,</li> <li><code>.md</code>: Markdown,</li> <li><code>.msg</code>: Outlook Message,</li> <li><code>.odt</code>: Open Document Text,</li> <li><code>.pdf</code>: Portable Document Format (PDF),</li> <li><code>.pptx</code> : PowerPoint Document,</li> <li><code>.ppt</code> : PowerPoint Document,</li> <li><code>.txt</code>: Text file (UTF-8),</li> </ul> <p>Run the following command to ingest all the data.</p> <pre><code>python ingest.py\n</code></pre> <p>Output should look like this:</p> <pre><code>Creating new vectorstore\nLoading documents from source_documents\nLoading new documents: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:01&lt;00:00,  1.73s/it]\nLoaded 1 new documents from source_documents\nSplit into 90 chunks of text (max. 500 tokens each)\nCreating embeddings. May take some minutes...\nUsing embedded DuckDB with persistence: data will be stored in: db\nIngestion complete! You can now run privateGPT.py to query your documents\n</code></pre> <p>It will create a <code>db</code> folder containing the local vectorstore. Will take 20-30 seconds per document, depending on the size of the document. You can ingest as many documents as you want, and all will be accumulated in the local embeddings database. If you want to start from an empty database, delete the <code>db</code> folder.</p> <p>Note: during the ingest process no data leaves your local environment. You could ingest without an internet connection, except for the first time you run the ingest script, when the embeddings model is downloaded.</p>"},{"location":"#ask-questions-to-your-documents-locally","title":"Ask questions to your documents, locally!","text":"<p>In order to ask a question, run a command like:</p> <pre><code>python privateGPT.py\n</code></pre> <p>And wait for the script to require your input.</p> <pre><code>&gt; Enter a query:\n</code></pre> <p>Hit enter. You'll need to wait 20-30 seconds (depending on your machine) while the LLM model consumes the prompt and prepares the answer. Once done, it will print the answer and the 4 sources it used as context from your documents; you can then ask another question without re-running the script, just wait for the prompt again.</p> <p>Note: you could turn off your internet connection, and the script inference would still work. No data gets out of your local environment.</p> <p>Type <code>exit</code> to finish the script.</p>"},{"location":"#cli","title":"CLI","text":"<p>The script also supports optional command-line arguments to modify its behavior. You can see a full list of these arguments by running the command <code>python privateGPT.py --help</code> in your terminal.</p>"},{"location":"#how-does-it-work","title":"How does it work?","text":"<p>Selecting the right local models and the power of <code>LangChain</code> you can run the entire pipeline locally, without any data leaving your environment, and with reasonable performance.</p> <ul> <li><code>ingest.py</code> uses <code>LangChain</code> tools to parse the document and create embeddings locally using <code>HuggingFaceEmbeddings</code> (<code>SentenceTransformers</code>). It then stores the result in a local vector database using <code>Chroma</code> vector store.</li> <li><code>privateGPT.py</code> uses a local LLM based on <code>GPT4All-J</code> or <code>LlamaCpp</code> to understand questions and create answers. The context for the answers is extracted from the local vector store using a similarity search to locate the right piece of context from the docs.</li> <li><code>GPT4All-J</code> wrapper was introduced in LangChain 0.0.162.</li> </ul>"},{"location":"#system-requirements","title":"System Requirements","text":""},{"location":"#python-version","title":"Python Version","text":"<p>To use this software, you must have Python 3.10 or later installed. Earlier versions of Python will not compile.</p>"},{"location":"#c-compiler","title":"C++ Compiler","text":"<p>If you encounter an error while building a wheel during the <code>pip install</code> process, you may need to install a C++ compiler on your computer.</p>"},{"location":"#for-windows-1011","title":"For Windows 10/11","text":"<p>To install a C++ compiler on Windows 10/11, follow these steps:</p> <ol> <li>Install Visual Studio 2022.</li> <li>Make sure the following components are selected:</li> <li>Universal Windows Platform development</li> <li>C++ CMake tools for Windows</li> <li>Download the MinGW installer from the MinGW website.</li> <li>Run the installer and select the <code>gcc</code> component.</li> </ol>"},{"location":"#mac-running-intel","title":"Mac Running Intel","text":"<p>When running a Mac with Intel hardware (not M1), you may run into clang: error: the clang compiler does not support '-march=native' during pip install.</p> <p>If so set your archflags during pip install. eg: ARCHFLAGS=\"-arch x86_64\" pip3 install -r requirements.txt</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This is a test project to validate the feasibility of a fully private solution for question answering using LLMs and Vector embeddings. It is not production ready, and it is not meant to be used in production. The models selection is not optimized for performance, but for privacy; but it is possible to use different models and vectorstores to improve performance.</p>"},{"location":"reference/","title":"Index","text":""},{"location":"reference/#privateGPT.main","title":"<code>main()</code>","text":"<p>Runs the main program.</p> <p>Returns:</p> Type Description <p>None</p> Side Effects <p>Prompts the user for a query and prints the answer and source documents.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; main()\nEnter a query: What is the capital of France?\n&gt; Question:\nWhat is the capital of France?\n&gt; Answer:\nParis\n</code></pre> Source code in <code>privateGPT.py</code> <pre><code>def main():\n\"\"\"\n    Runs the main program.\n    Args:\n      None\n    Returns:\n      None\n    Side Effects:\n      Prompts the user for a query and prints the answer and source documents.\n    Examples:\n      &gt;&gt;&gt; main()\n      Enter a query: What is the capital of France?\n      &gt; Question:\n      What is the capital of France?\n      &gt; Answer:\n      Paris\n    \"\"\"\n    # Parse the command line arguments\n    args = parse_arguments()\n    embeddings = HuggingFaceEmbeddings(model_name=embeddings_model_name)\n    db = Chroma(persist_directory=persist_directory, embedding_function=embeddings, client_settings=CHROMA_SETTINGS)\n    retriever = db.as_retriever(search_kwargs={\"k\": target_source_chunks})\n    # activate/deactivate the streaming StdOut callback for LLMs\n    callbacks = [] if args.mute_stream else [StreamingStdOutCallbackHandler()]\n    # Prepare the LLM\n    match model_type:\n        case \"LlamaCpp\":\n            llm = LlamaCpp(model_path=model_path, n_ctx=model_n_ctx, callbacks=callbacks, verbose=False)\n        case \"GPT4All\":\n            llm = GPT4All(model=model_path, n_ctx=model_n_ctx, backend='gptj', callbacks=callbacks, verbose=False)\n        case _default:\n            print(f\"Model {model_type} not supported!\")\n            exit;\n    qa = RetrievalQA.from_chain_type(llm=llm, chain_type=\"stuff\", retriever=retriever, return_source_documents= not args.hide_source)\n    # Interactive questions and answers\n    while True:\n        query = input(\"\\nEnter a query: \")\n        if query == \"exit\":\n            break\n\n        # Get the answer from the chain\n        res = qa(query)\n        answer, docs = res['result'], [] if args.hide_source else res['source_documents']\n\n        # Print the result\n        print(\"\\n\\n&gt; Question:\")\n        print(query)\n        print(\"\\n&gt; Answer:\")\n        print(answer)\n\n        # Print the relevant sources used for the answer\n        for document in docs:\n            print(\"\\n&gt; \" + document.metadata[\"source\"] + \":\")\n            print(document.page_content)\n</code></pre>"},{"location":"reference/#privateGPT.parse_arguments","title":"<code>parse_arguments()</code>","text":"<p>Parses the command line arguments.</p> <p>Returns:</p> Type Description <p>argparse.Namespace: The parsed arguments.</p> Side Effects <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parse_arguments()\nNamespace(hide_source=False, mute_stream=False)\n</code></pre> Source code in <code>privateGPT.py</code> <pre><code>def parse_arguments():\n\"\"\"\n    Parses the command line arguments.\n    Args:\n      None\n    Returns:\n      argparse.Namespace: The parsed arguments.\n    Side Effects:\n      None\n    Examples:\n      &gt;&gt;&gt; parse_arguments()\n      Namespace(hide_source=False, mute_stream=False)\n    \"\"\"\n    parser = argparse.ArgumentParser(description='privateGPT: Ask questions to your documents without an internet connection, '\n                                                 'using the power of LLMs.')\n    parser.add_argument(\"--hide-source\", \"-S\", action='store_true',\n                        help='Use this flag to disable printing of source documents used for answers.')\n\n    parser.add_argument(\"--mute-stream\", \"-M\",\n                        action='store_true',\n                        help='Use this flag to disable the streaming StdOut callback for LLMs.')\n\n    return parser.parse_args()\n</code></pre>"},{"location":"reference/#ingest.MyElmLoader","title":"<code>MyElmLoader</code>","text":"<p>         Bases: <code>UnstructuredEmailLoader</code></p> <p>Wrapper to fallback to text/plain when default does not work.</p> Source code in <code>ingest.py</code> <pre><code>class MyElmLoader(UnstructuredEmailLoader):\n\"\"\"\n    Wrapper to fallback to text/plain when default does not work.\n    \"\"\"\n\n    def load(self) -&gt; List[Document]:\n\"\"\"\n        Wrapper adding fallback for elm without html.\n        Args:\n            self (MyElmLoader): The MyElmLoader instance.\n        Returns:\n            List[Document]: The list of documents.\n        Raises:\n            ValueError: If an unsupported file extension is encountered.\n        Examples:\n            &gt;&gt;&gt; MyElmLoader.load(self)\n            [Document]\n        \"\"\"\n\n        try:\n            try:\n                doc = UnstructuredEmailLoader.load(self)\n            except ValueError as e:\n                if 'text/html content not found in email' in str(e):\n                    # Try plain text\n                    self.unstructured_kwargs[\"content_source\"]=\"text/plain\"\n                    doc = UnstructuredEmailLoader.load(self)\n                else:\n                    raise\n        except Exception as e:\n            # Add file_path to exception message\n            raise type(e)(f\"{self.file_path}: {e}\") from e\n\n        return doc\n</code></pre>"},{"location":"reference/#ingest.MyElmLoader.load","title":"<code>load()</code>","text":"<p>Wrapper adding fallback for elm without html.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>MyElmLoader</code> <p>The MyElmLoader instance.</p> required <p>Returns:</p> Type Description <code>List[Document]</code> <p>List[Document]: The list of documents.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported file extension is encountered.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MyElmLoader.load(self)\n[Document]\n</code></pre> Source code in <code>ingest.py</code> <pre><code>def load(self) -&gt; List[Document]:\n\"\"\"\n    Wrapper adding fallback for elm without html.\n    Args:\n        self (MyElmLoader): The MyElmLoader instance.\n    Returns:\n        List[Document]: The list of documents.\n    Raises:\n        ValueError: If an unsupported file extension is encountered.\n    Examples:\n        &gt;&gt;&gt; MyElmLoader.load(self)\n        [Document]\n    \"\"\"\n\n    try:\n        try:\n            doc = UnstructuredEmailLoader.load(self)\n        except ValueError as e:\n            if 'text/html content not found in email' in str(e):\n                # Try plain text\n                self.unstructured_kwargs[\"content_source\"]=\"text/plain\"\n                doc = UnstructuredEmailLoader.load(self)\n            else:\n                raise\n    except Exception as e:\n        # Add file_path to exception message\n        raise type(e)(f\"{self.file_path}: {e}\") from e\n\n    return doc\n</code></pre>"},{"location":"reference/#ingest.does_vectorstore_exist","title":"<code>does_vectorstore_exist(persist_directory)</code>","text":"<p>Checks if vectorstore exists.</p> <p>Parameters:</p> Name Type Description Default <code>persist_directory</code> <code>str</code> <p>The directory of the vectorstore.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if vectorstore exists, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; does_vectorstore_exist('persist_directory')\nTrue\n</code></pre> Source code in <code>ingest.py</code> <pre><code>def does_vectorstore_exist(persist_directory: str) -&gt; bool:\n\"\"\"\n    Checks if vectorstore exists.\n    Args:\n      persist_directory (str): The directory of the vectorstore.\n    Returns:\n      bool: True if vectorstore exists, False otherwise.\n    Examples:\n      &gt;&gt;&gt; does_vectorstore_exist('persist_directory')\n      True\n    \"\"\"\n    if os.path.exists(os.path.join(persist_directory, 'index')):\n        if os.path.exists(os.path.join(persist_directory, 'chroma-collections.parquet')) and os.path.exists(os.path.join(persist_directory, 'chroma-embeddings.parquet')):\n            list_index_files = glob.glob(os.path.join(persist_directory, 'index/*.bin'))\n            list_index_files += glob.glob(os.path.join(persist_directory, 'index/*.pkl'))\n            # At least 3 documents are needed in a working vectorstore\n            if len(list_index_files) &gt; 3:\n                return True\n    return False\n</code></pre>"},{"location":"reference/#ingest.load_documents","title":"<code>load_documents(source_dir, ignored_files=[])</code>","text":"<p>Loads all documents from the source documents directory, ignoring specified files.</p> <p>Parameters:</p> Name Type Description Default <code>source_dir</code> <code>str</code> <p>The source directory of the documents.</p> required <code>ignored_files</code> <code>List[str]</code> <p>The list of files to ignore. Defaults to [].</p> <code>[]</code> <p>Returns:</p> Type Description <code>List[Document]</code> <p>List[Document]: The list of documents.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; load_documents('source_documents', ['example.txt'])\n[Document]\n</code></pre> Source code in <code>ingest.py</code> <pre><code>def load_documents(source_dir: str, ignored_files: List[str] = []) -&gt; List[Document]:\n\"\"\"\n    Loads all documents from the source documents directory, ignoring specified files.\n    Args:\n      source_dir (str): The source directory of the documents.\n      ignored_files (List[str], optional): The list of files to ignore. Defaults to [].\n    Returns:\n      List[Document]: The list of documents.\n    Examples:\n      &gt;&gt;&gt; load_documents('source_documents', ['example.txt'])\n      [Document]\n    \"\"\"\n    all_files = []\n    for ext in LOADER_MAPPING:\n        all_files.extend(\n            glob.glob(os.path.join(source_dir, f\"**/*{ext}\"), recursive=True)\n        )\n    filtered_files = [file_path for file_path in all_files if file_path not in ignored_files]\n\n    with Pool(processes=os.cpu_count()) as pool:\n        results = []\n        with tqdm(total=len(filtered_files), desc='Loading new documents', ncols=80) as pbar:\n            for i, docs in enumerate(pool.imap_unordered(load_single_document, filtered_files)):\n                results.extend(docs)\n                pbar.update()\n\n    return results\n</code></pre>"},{"location":"reference/#ingest.load_single_document","title":"<code>load_single_document(file_path)</code>","text":"<p>Loads a single document from a file path.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The file path of the document.</p> required <p>Returns:</p> Type Description <code>List[Document]</code> <p>List[Document]: The list of documents.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported file extension is encountered.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; load_single_document('example.txt')\n[Document]\n</code></pre> Source code in <code>ingest.py</code> <pre><code>def load_single_document(file_path: str) -&gt; List[Document]:\n\"\"\"\n    Loads a single document from a file path.\n    Args:\n      file_path (str): The file path of the document.\n    Returns:\n      List[Document]: The list of documents.\n    Raises:\n      ValueError: If an unsupported file extension is encountered.\n    Examples:\n      &gt;&gt;&gt; load_single_document('example.txt')\n      [Document]\n    \"\"\"\n    ext = \".\" + file_path.rsplit(\".\", 1)[-1]\n    if ext in LOADER_MAPPING:\n        loader_class, loader_args = LOADER_MAPPING[ext]\n        loader = loader_class(file_path, **loader_args)\n        return loader.load()\n\n    raise ValueError(f\"Unsupported file extension '{ext}'\")\n</code></pre>"},{"location":"reference/#ingest.main","title":"<code>main()</code>","text":"<p>Create embeddings, check if vectorstore exists, and update/create vectorstore.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; main()\nIngestion complete! You can now run privateGPT.py to query your documents\n</code></pre> Source code in <code>ingest.py</code> <pre><code>def main():\n\"\"\"\n    Create embeddings, check if vectorstore exists, and update/create vectorstore.\n    Examples:\n      &gt;&gt;&gt; main()\n      Ingestion complete! You can now run privateGPT.py to query your documents\n    \"\"\"\n    # Create embeddings\n    embeddings = HuggingFaceEmbeddings(model_name=embeddings_model_name)\n\n    if does_vectorstore_exist(persist_directory):\n        # Update and store locally vectorstore\n        print(f\"Appending to existing vectorstore at {persist_directory}\")\n        db = Chroma(persist_directory=persist_directory, embedding_function=embeddings, client_settings=CHROMA_SETTINGS)\n        collection = db.get()\n        texts = process_documents([metadata['source'] for metadata in collection['metadatas']])\n        print(f\"Creating embeddings. May take some minutes...\")\n        db.add_documents(texts)\n    else:\n        # Create and store locally vectorstore\n        print(\"Creating new vectorstore\")\n        texts = process_documents()\n        print(f\"Creating embeddings. May take some minutes...\")\n        db = Chroma.from_documents(texts, embeddings, persist_directory=persist_directory, client_settings=CHROMA_SETTINGS)\n    db.persist()\n    db = None\n\n    print(f\"Ingestion complete! You can now run privateGPT.py to query your documents\")\n</code></pre>"},{"location":"reference/#ingest.process_documents","title":"<code>process_documents(ignored_files=[])</code>","text":"<p>Load documents and split in chunks.</p> <p>Parameters:</p> Name Type Description Default <code>ignored_files</code> <code>List[str]</code> <p>The list of files to ignore. Defaults to [].</p> <code>[]</code> <p>Returns:</p> Type Description <code>List[Document]</code> <p>List[Document]: The list of documents.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; process_documents(['example.txt'])\n[Document]\n</code></pre> Source code in <code>ingest.py</code> <pre><code>def process_documents(ignored_files: List[str] = []) -&gt; List[Document]:\n\"\"\"\n    Load documents and split in chunks.\n    Args:\n      ignored_files (List[str], optional): The list of files to ignore. Defaults to [].\n    Returns:\n      List[Document]: The list of documents.\n    Examples:\n      &gt;&gt;&gt; process_documents(['example.txt'])\n      [Document]\n    \"\"\"\n    print(f\"Loading documents from {source_directory}\")\n    documents = load_documents(source_directory, ignored_files)\n    if not documents:\n        print(\"No new documents to load\")\n        exit(0)\n    print(f\"Loaded {len(documents)} new documents from {source_directory}\")\n    text_splitter = RecursiveCharacterTextSplitter(chunk_size=chunk_size, chunk_overlap=chunk_overlap)\n    texts = text_splitter.split_documents(documents)\n    print(f\"Split into {len(texts)} chunks of text (max. {chunk_size} tokens each)\")\n    return texts\n</code></pre>"}]}